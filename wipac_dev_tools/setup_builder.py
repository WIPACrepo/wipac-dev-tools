"""Module to build `setup.cfg` sections for use by `setup.py`/`setuptools`.

Used in CI/CD, used by GH Action.
"""

import configparser
import re
from dataclasses import dataclass
from typing import List, Tuple, cast

SETUP_CFG = "setup.cfg"
BUIDLER_SECTION_NAME = "wipac:cicd_setup_builder"
GENERATED_COMMENT = f"# generated by {BUIDLER_SECTION_NAME}"
AUTHOR = "WIPAC Developers"
AUTHOR_EMAIL = "developers@icecube.wisc.edu"
DEFAULT_KEYWORDS = ["WIPAC", "IceCube"]
LICENSE = "MIT"

PythonMinMax = Tuple[Tuple[int, int], Tuple[int, int]]


@dataclass
class BuilderSection:
    """Encapsulates the `BUIDLER_SECTION_NAME` section & checks for required/invalid fields."""

    pypi_name: str
    version_location: str
    description: str
    url: str
    python_range: str  # python_requires
    main_or_master: str = "main"
    keywords: str = ""  # comes as raw "A, B, C" or "A\nB\nC"

    def _python_min_max(self) -> PythonMinMax:
        """Get the `PythonMinMax` version of `self.python_range`."""
        m = re.match(
            r"(?P<lo_maj>\d+)\.(?P<lo_min>\d+) *- *(?P<hi_maj>\d+)\.(?P<hi_min>\d+).*",
            self.python_range,
        )
        assert m  # TODO
        versions = (
            (int(m.groupdict()["lo_maj"]), int(m.groupdict()["lo_min"])),
            (int(m.groupdict()["hi_maj"]), int(m.groupdict()["hi_min"])),
        )
        return cast(PythonMinMax, tuple(sorted(versions)))

    def python_requires(self) -> str:
        """Get a `[metadata]/python_requires` string from `self.python_range`.

        Ex: "">=3.6, <=3.10"
        """
        py_min_max = self._python_min_max()
        return f">={py_min_max[0][0]}.{py_min_max[0][1]}, <={py_min_max[1][0]}.{py_min_max[1][1]}"

    def python_classifiers(self) -> List[str]:
        """Get auto-detected `Programming Language :: Python :: *` list.

        NOTE: Will not work after the '3.* -> 4.0'-transition.
        """
        py_min_max = self._python_min_max()
        if py_min_max[0][0] < 3:
            raise Exception("Python-classifier automation does not work for python <3.")
        if py_min_max[1][0] >= 4:
            raise Exception("Python-classifier automation does not work for python 4+.")

        return [
            f"Programming Language :: Python :: 3.{r}"
            for r in range(py_min_max[0][1], py_min_max[1][1] + 1)
        ]


def list_to_dangling(lines: List[str]) -> str:
    """Create a "dangling"-lines formatted list."""
    return "\n" + "\n".join(lines)


def _build_out_sections(cfg: configparser.RawConfigParser) -> None:
    """Build out the `[metadata]`, `[semantic_release]`, and `[options]` sections."""

    # cast to dataclass (which also checks for fields)
    bsec = BuilderSection(**dict(cfg[BUIDLER_SECTION_NAME]))

    # [metadata]
    cfg["metadata"] = {
        "name": bsec.pypi_name,
        # "wipac_dev_tools/__init__.py:__version__" -> wipac_dev_tools.__version__
        "version": f"attr: {bsec.version_location.replace('/__init__.py:', '.')}",  # TODO working?
        "author": AUTHOR,
        "author_email": AUTHOR_EMAIL,
        "description": bsec.description,
        # TODO -- how can we get a readme without being told where it is?
        "long_description": "file: README.md, CHANGELOG.md, LICENSE.md, README.rst, CHANGELOG.rst, LICENSE.rst",
        "long_description_content_type": "",  # TODO
        "keywords": list_to_dangling(DEFAULT_KEYWORDS),  # TODO
        "license": LICENSE,
        # TODO: add "Development Status :: *", any way to do this without knowing abspath?
        "classifiers": list_to_dangling(bsec.python_classifiers()),
    }

    # [semantic_release]
    cfg["semantic_release"] = {
        "version_variable": bsec.version_location,  # "wipac_dev_tools/__init__.py:__version__"
        "upload_to_pypi": "True",
        "patch_without_tag": "True",
        "commit_parser": "semantic_release.history.tag_parser",
        "minor_tag": "[minor]",
        "fix_tag": "[fix]",
        "branch": bsec.main_or_master,
    }

    # [options] -- override specific options
    # TODO: check that this commenting works -- otherwise, get smart with adding after `write()`
    cfg["options"]["python_requires"] = f"{bsec.python_requires()}  {GENERATED_COMMENT}"
    cfg["options"]["packages"] = f"find:  {GENERATED_COMMENT}"  # TODO: 'find:' working?


def build() -> None:
    """Build the `setup.cfg` sections according to `[wipac:cicd_setup_builder]`."""
    cfg = configparser.RawConfigParser(allow_no_value=True, comment_prefixes="/")
    cfg.read(SETUP_CFG)
    assert cfg.has_section(BUIDLER_SECTION_NAME)  # TODO
    cfg.remove_section("metadata")  # will be overridden
    cfg.remove_section("semantic_release")  # will be overridden
    if not cfg.has_section("options"):  # will only override some options (fields)
        cfg["options"] = {}

    # NOTE: 'install_requires' (& 'extras_require') are important and shouldn't be overridden

    _build_out_sections(cfg)

    # Re-order some sections to the top
    tops = [BUIDLER_SECTION_NAME, "metadata", "semantic_release", "options"]
    for sec in cfg.sections():  # and any 'options.*', if present
        if sec.startswith("options."):
            tops.append(sec)

    # Build new 'setup.cfg'
    cfg_new = configparser.RawConfigParser()
    for sec in tops:
        cfg_new[sec] = cfg[sec]
    for sec in cfg.sections():  # add rest of existing sections
        if sec not in tops:
            cfg_new[sec] = cfg[sec]
    cfg_new.write(open(SETUP_CFG, "w"))

    # Comment generated sections w/ comments saying so
    with open(SETUP_CFG) as f:
        c = f.read()
        c = c.replace("[metadata]", f"[metadata]  {GENERATED_COMMENT}")
        c = c.replace("[semantic_release]", f"[semantic_release]  {GENERATED_COMMENT}")
        print(c)
    with open(SETUP_CFG, "w") as f:
        f.write(c)
