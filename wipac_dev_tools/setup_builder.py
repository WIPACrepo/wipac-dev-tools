"""Module to build `setup.cfg` sections for use by `setup.py`/`setuptools`.

Used in CI/CD, used by GH Action.
"""

import configparser
import re
from typing import Any, Dict, List, Tuple, cast

SETUP_CFG = "setup.cfg"
BUIDLER_SECTION_NAME = "wipac:cicd_setup_builder"
GENERATED_COMMENT = f"# generated by {BUIDLER_SECTION_NAME}"
AUTHOR = "WIPAC Developers"
AUTHOR_EMAIL = "developers@icecube.wisc.edu"
DEFAULT_KEYWORDS = ["WIPAC", "IceCube"]
LICENSE = "MIT"


PythonMinMax = Tuple[Tuple[int, int], Tuple[int, int]]


def _python_range(python_range: str) -> PythonMinMax:
    m = re.match(
        r"(?P<lo_maj>\d+)\.(?P<lo_min>\d+) *- *(?P<hi_maj>\d+)\.(?P<hi_min>\d+).*",
        python_range,
    )
    assert m  # TODO
    versions = (
        (int(m.groupdict()["lo_maj"]), int(m.groupdict()["lo_min"])),
        (int(m.groupdict()["hi_maj"]), int(m.groupdict()["hi_min"])),
    )
    return cast(PythonMinMax, tuple(sorted(versions)))


def _get_py_classifiers(py_min_max: PythonMinMax) -> List[str]:
    """Get auto-detected `Programming Language :: Python :: *` list.

    NOTE: Will not work after the '3.* -> 4.0'-transition.
    """
    if py_min_max[0][0] < 3:
        raise Exception("Python-classifier automation does not work for python <3.")
    if py_min_max[1][0] >= 4:
        raise Exception("Python-classifier automation does not work for python 4+.")

    return [
        f"Programming Language :: Python :: 3.{r}"
        for r in range(py_min_max[0][1], py_min_max[1][1] + 1)
    ]


def _metadata(
    pypi_name: str, py_min_max: PythonMinMax, version_location: str, description: str
) -> Dict[str, Any]:
    """Build the [metadata] section"""

    def list_to_dangling(lines: List[str]) -> str:
        """Create a "dangling"-lines formatted list."""
        return "\n" + "\n".join(lines)

    sec = {
        "name": pypi_name,
        # "wipac_dev_tools/__init__.py:__version__" -> wipac_dev_tools.__version__
        "version": f"attr: {version_location.replace('/__init__.py:', '.')}",  # TODO working?
        "author": AUTHOR,
        "author_email": AUTHOR_EMAIL,
        "description": description,
        # TODO -- how can we get a readme without being told where it is?
        "long_description": "file: README.md, CHANGELOG.md, LICENSE.md, README.rst, CHANGELOG.rst, LICENSE.rst",
        "long_description_content_type": "",  # TODO
        "keywords": list_to_dangling(DEFAULT_KEYWORDS),  # TODO
        "license": LICENSE,
        # TODO: add "Development Status :: *", any way to do this without knowing abspath?
        "classifiers": list_to_dangling(_get_py_classifiers(py_min_max)),
    }
    return sec


def _semantic_release(version_location: str, main_or_master: str) -> Dict[str, Any]:
    """Build the [semantic_release] section"""
    sec = {
        "version_variable": version_location,  # "wipac_dev_tools/__init__.py:__version__"
        "upload_to_pypi": "True",
        "patch_without_tag": "True",
        "commit_parser": "semantic_release.history.tag_parser",
        "minor_tag": "[minor]",
        "fix_tag": "[fix]",
        "branch": main_or_master,
    }

    return sec


def _build_out_sections(cfg: configparser.RawConfigParser) -> None:
    buidler_section = cfg[BUIDLER_SECTION_NAME]
    py_min_max = _python_range(buidler_section["python_range"])

    # [metadata]
    cfg["metadata"] = _metadata(
        buidler_section["pypi_name"],
        py_min_max,
        buidler_section["version_location"],
        buidler_section["description"],
    )

    # [semantic_release]
    cfg["semantic_release"] = _semantic_release(
        buidler_section["version_location"],
        buidler_section["main_or_master"],
    )

    # [options] -- override specific options
    py_reqs = f">={py_min_max[0][0]}.{py_min_max[0][1]}, <={py_min_max[1][0]}.{py_min_max[1][1]}"
    # TODO: check that this commenting works -- otherwise, get smart with adding after `write()`
    cfg["options"]["python_requires"] = f"{py_reqs}  {GENERATED_COMMENT}"
    cfg["options"]["packages"] = f"find:  {GENERATED_COMMENT}"  # TODO: 'find:' working?


def build() -> None:
    """Build the `setup.cfg` sections according to `[wipac:cicd_setup_builder]`."""
    cfg = configparser.RawConfigParser(allow_no_value=True, comment_prefixes="/")
    cfg.read(SETUP_CFG)
    assert cfg.has_section(BUIDLER_SECTION_NAME)  # TODO
    cfg.remove_section("metadata")  # will be overridden
    cfg.remove_section("semantic_release")  # will be overridden
    if not cfg.has_section("options"):  # will only override some options
        cfg["options"] = {}

    # NOTE: 'install_requires' (& 'extras_require') are important and shouldn't be overridden

    _build_out_sections(cfg)

    # Re-order some sections to the top
    tops = [BUIDLER_SECTION_NAME, "metadata", "semantic_release", "options"]
    for sec in cfg.sections():  # and any 'options.*', if present
        if sec.startswith("options."):
            tops.append(sec)

    # Build new 'setup.cfg'
    cfg_new = configparser.RawConfigParser()
    for sec in tops:
        cfg_new[sec] = cfg[sec]
    for sec in cfg.sections():  # add rest of existing sections
        if sec not in tops:
            cfg_new[sec] = cfg[sec]
    cfg_new.write(open(SETUP_CFG, "w"))

    # Comment generated sections w/ comments saying so
    with open(SETUP_CFG) as f:
        c = f.read()
        c = c.replace("[metadata]", f"[metadata]  {GENERATED_COMMENT}")
        c = c.replace("[semantic_release]", f"[semantic_release]  {GENERATED_COMMENT}")
        print(c)
    with open(SETUP_CFG, "w") as f:
        f.write(c)
